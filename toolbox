#!/usr/bin/bash
SHELL=/usr/bin/bash
#
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
#  published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# =======================
# Detect the source where ToolBox is run from to be able to Update it
_toolbox_sourcefile() {
  SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  TARGET="$(readlink "$SOURCE")"
  if [[ $TARGET == /* ]]; then
    #echo "SOURCE '$SOURCE' is an absolute symlink to '$TARGET'"
    SOURCE="$TARGET"
  else
    DIR="$( dirname "$SOURCE" )"
    #echo "SOURCE '$SOURCE' is a relative symlink to '$TARGET' (relative to '$DIR')"
    SOURCE="$DIR/$TARGET" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
  fi
done
echo "SOURCE is '$SOURCE'"
RDIR="$( dirname "$SOURCE" )"
DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
if [ "$DIR" != "$RDIR" ]; then
  echo "DIR '$RDIR' resolves to '$DIR'"
fi
#echo "DIR is '$DIR'"
rm $HOME/.cache/toolbox/toolboxpath.txt &>/dev/null
echo "$DIR" >> $HOME/.cache/toolbox/toolboxpath.txt # Write path of ToolBox to a file to be able to read from it
}
#
# =======================
# Compare and Download latest version of PacUI - Releasecompare - Manjao Update - ToolBox
# This functions run in _update_check
#
# ToolBox Update Check
_toolbox_version_check() {
  toolbox="$(cat toolboxpath.txt)" # Check where the ToolBox script is located to be able to update it
  cd $toolbox
  wget https://raw.githubusercontent.com/puxplaying/ToolBox/master/toolbox &>/dev/null # Download online version
  cat toolbox.* | tee toolbox_online.txt &>/dev/null
  rm -rf toolbox.* &>/dev/null # Clean temp files

  # Get md5sum of local and online version
  REMOTEMD5=$(md5sum 'toolbox' | cut -d" " -f1)
  LOCALMD5=$(md5sum 'toolbox_online.txt' | cut -d" " -f1)

    # Compare md5sum of local and online version
    if [ "$LOCALMD5" == "$REMOTEMD5" ] # If md5sums are the same
    then
      echo -e "\e[1m ToolBox \e[0m- is Up to date!"
      rm -rf toolbox_online.txt &>/dev/null
    else
      printf '\33[H\33[2J'
      echo -e "no match, Local:"$LOCALMD5"\nRemote:"$REMOTEMD5
      echo "Starting ToolBox Update ..."
      rm -rf toolbox &>/dev/null
      wget https://raw.githubusercontent.com/puxplaying/ToolBox/master/toolbox &>/dev/null
      chmod a+rx toolbox
      rm -rf toolbox_online.txt &>/dev/null
      rm -rf "$HOME/.cache/toolbox"
      echo "... ToolBox updated to latest Git version!"
      echo "... Cache Deleted!"
      echo -e "\e[41m Please restart ToolBox! \e[0m"
      echo ""

fi
}
#
# manjaro_update - Update Check
_manjaro_update_version_check() {
  wget https://raw.githubusercontent.com/puxplaying/manjaro-update/master/manjaro_update &>/dev/null
  cat manjaro_update.* | tee manjaro_update_online.txt &>/dev/null
  rm -rf manjaro_update.* &>/dev/null

  REMOTEMD5=$(md5sum 'manjaro_update' | cut -d" " -f1)
  LOCALMD5=$(md5sum 'manjaro_update_online.txt' | cut -d" " -f1)


    if [ "$LOCALMD5" == "$REMOTEMD5" ]
    then
      echo -e "\e[1m manjaro_update \e[0m- is Up to date!"
      rm -rf manjaro_update_online.txt &>/dev/null
    else
      printf '\33[H\33[2J'
      echo -e "no match, Local:"$LOCALMD5"\nRemote:"$REMOTEMD5
      echo "Starting manjaro_update Update ..."
      rm -rf manjaro_update &>/dev/null
      wget https://raw.githubusercontent.com/puxplaying/manjaro-update/master/manjaro_update &>/dev/null
      chmod a+rx manjaro_update
      rm -rf manjaro_update_online.txt &>/dev/null
      echo "... manjaro_update updated to latest Git version!"
      echo ""

fi
}
#
# releasecompare Update Check
_releasecompare_version_check() {
  wget https://raw.githubusercontent.com/puxplaying/releasecompare/master/releasecompare &>/dev/null
  cat releasecompare.* | tee releasecompare_online.txt &>/dev/null
  rm -rf releasecompare.* &>/dev/null

  REMOTEMD5=$(md5sum 'releasecompare' | cut -d" " -f1)
  LOCALMD5=$(md5sum 'releasecompare_online.txt' | cut -d" " -f1)


    if [ "$LOCALMD5" == "$REMOTEMD5" ]
    then
      echo -e "\e[1m releasecompare \e[0m- is Up to date!"
      rm -rf releasecompare_online.txt &>/dev/null
    else
      printf '\33[H\33[2J'
      echo -e "no match, Local:"$LOCALMD5"\nRemote:"$REMOTEMD5
      echo "Starting releasecompare Update ..."
      rm -rf releasecompare &>/dev/null
      wget https://raw.githubusercontent.com/puxplaying/releasecompare/master/releasecompare &>/dev/null
      chmod a+rx releasecompare
      rm -rf releasecompare_online.txt &>/dev/null
      echo "... releasecompare updated to latest Git version!"
      echo ""

fi
}
#
# PacUI Update Check
_pacui_version_check() {
  wget https://raw.githubusercontent.com/excalibur1234/pacui/master/pacui &>/dev/null
  cat pacui.* | tee pacui_online.txt &>/dev/null
  rm -rf pacui.* &>/dev/null

  REMOTEMD5=$(md5sum 'pacui' | cut -d" " -f1)
  LOCALMD5=$(md5sum 'pacui_online.txt' | cut -d" " -f1)


    if [ "$LOCALMD5" == "$REMOTEMD5" ]
    then
      echo -e "\e[1m PacUI \e[0m- is Up to date!"
      rm -rf pacui_online.txt &>/dev/null
    else
      printf '\33[H\33[2J'
      echo -e "no match, Local:"$LOCALMD5"\nRemote:"$REMOTEMD5
      echo "Starting PacUI Update ..."
      rm -rf pacui &>/dev/null
      wget https://raw.githubusercontent.com/excalibur1234/pacui/master/pacui &>/dev/null
      chmod a+rx pacui
      rm -rf pacui_online.txt &>/dev/null
      echo "... PacUI updated to latest Git version!"
      echo ""

fi
}
#
# Ranger Update Check
_ranger_version_check() {
  test -d "$HOME/.cache/toolbox/temp" || mkdir -p "$HOME/.cache/toolbox/temp" && cd $HOME/.cache/toolbox/temp
  wget https://github.com/ranger/ranger/archive/master.zip &>/dev/null
  unzip master.zip &>/dev/null

  REMOTEMD5=$(tar -cf - master.zip | md5sum | cut -d" " -f1)
  LOCALMD5=$(tar -cf - master.zip | md5sum | cut -d" " -f1)

  if [ "$LOCALMD5" == "$REMOTEMD5" ]
  then
    echo -e "\e[1m Ranger \e[0m- is Up to date!"
    cd $HOME/.cache/toolbox
    rm -rf "$HOME/.cache/toolbox/temp"
  else
    printf '\33[H\33[2J'
    echo -e "no match, Local:"$LOCALMD5"\nRemote:"$REMOTEMD5
    echo "Starting Ranger Update ..."
    cd $HOME/.cache/toolbox
    rm -rf "$HOME/.cache/toolbox/ranger-master"
    wget https://github.com/ranger/ranger/archive/master.zip &>/dev/null
    unzip master.zip &>/dev/null
    cp master.zip ranger-master &>/dev/null
    rm -rf master.zip &>/dev/null
    echo -e "\e[1m Ranger \e[0m- is Up to date!"

fi
}
#
# Browsh Browser Update Check
_browsh_version_check() {
  # Online Version
  VERSION=$(curl -s https://github.com/browsh-org/browsh/releases/latest/download 2>&1 | grep -Po [0-9]+\.[0-9]+\.[0-9]+)
  #echo Online Version: $VERSION
  # Local Version
  VERSION2=$(echo browsh* 2>&1 | grep -Po [0-9]+\.[0-9]+\.[0-9]+)
  #echo Local Version: $VERSION2

  if [ "$VERSION" == "$VERSION2" ]
  then
    echo -e "\e[1m Browsh \e[0m- is Up to date!"
  else
    printf '\33[H\33[2J'
    echo -e "no match, Local:"$VERSION2"\nRemote:"$VERSION
    echo "Starting Browsh Update ..."
    rm -rf browsh* &>/dev/null
    wget https://github.com/browsh-org/browsh/releases/download/v$VERSION/browsh_"$VERSION"_linux_amd64 &>/dev/null
    chmod a+rx browsh*
    echo "... Browsh updated to latest release version!"
    echo ""

fi
}
#
# =======================
# Update Checker - Option 00
_update_check() {
  cd $HOME/.cache/toolbox
  echo "Checking for Updates ..."
  _manjaro_update_version_check
  _releasecompare_version_check
  _pacui_version_check
  _ranger_version_check
  _browsh_version_check

  if [[ -f toolboxpath.txt ]] # Check for ToolBox directory
	then
		_toolbox_version_check
    #echo "toolbox test"
	fi

}
#
# =======================
# First launch Check for requiered scripts
# Make a directory in "$HOME/.cache/toolbox" where all scripts will be stored and check for its existence on start of ToolBox.
_initupdate() {
  if [ ! -d "$HOME/.cache/toolbox" ]
  then
    echo "ToolBox Data not found!"
    echo "Downloading ..."
    # Get all requiered scripts online to be up to date
    test -d "$HOME/.cache/toolbox" || mkdir -p "$HOME/.cache/toolbox" && cd $HOME/.cache/toolbox
    wget https://raw.githubusercontent.com/puxplaying/manjaro-update/master/manjaro_update &>/dev/null
    wget https://raw.githubusercontent.com/puxplaying/releasecompare/master/releasecompare &>/dev/null
    wget https://raw.githubusercontent.com/excalibur1234/pacui/master/pacui &>/dev/null
    wget https://github.com/ranger/ranger/archive/master.zip &>/dev/null
    unzip master.zip &>/dev/null
    cp master.zip ranger-master &>/dev/null
    rm -rf master.zip &>/dev/null
    _browsh_version_check
    chmod a+rx pacui releasecompare manjaro_update browsh*

  else
    echo "ToolBox Data found!"
    _toolbox_sourcefile # Recreate the the source file location of ToolBox on restart in case the script has been moved.

  fi
}
# =======================
_initupdate
#
# =======================
# Startmenu for releasecompare
_releasecompare_startmenu() {
  echo ""
  echo -e "\e[7m This tool will compare the latest Manjaro release to the local system \e[0m"
  echo -e "\e[7m to see which applications may have been added to new releases! \e[0m"
  echo ""
  echo -e "\e[7m Chose what to do! \e[0m"
  echo ""
  echo "  1) Compare only"
  echo "  2) Installation Options"
  echo "  3) Quit"
read -r choice
case "$choice" in
        1)
            echo "you chose to compare only"
            sh $HOME/.cache/toolbox/releasecompare
            ;;
        2)
            echo "you chose Installation Options"
            sh $HOME/.cache/toolbox/releasecompare install
            ;;
        3|q|quit)
            return
            ;;
        * ) echo "invalid option $REPLY"
            ;;
    esac
}
#
# =======================
# UI code is below
function ui_clean
{
        # the traditional "clear" command does not work as expected on all systems. problem: the terminal history of all previous commands is deleted when the "clear" command is used. solution: do everything i expect from "clear" manually. this keeps the terminal history:

        local lines
        # number of lines of the user's terminal.
        lines="$( tput lines )"
        for (( i=1; i<lines; i++ ))
        do
                # insert "lines" number of empty lines:
                echo
        done

        # move cursor to the top left of the terminal
        tput cup 0 0
}



# Run infinite loop for UI / menu, till the user quits using the "quit" option or CTRL+C.
while true
do

    ui_clean                                                                     # clear the terminal screen

    # draw UI / menu. please note the use of ANSI Escape sequences mentioned at the top. The text/code can be hard to read and should be changed carefully: spaces are important here!
    echo
    echo -e "                              \e[7m ToolBox \e[0m                                     "
    echo -e " \e[1m+------------------------------------------------------------------+\e[0m"
    echo -e " \e[1m|\e[0m    \e[7m 1  \e[0m \e[1mS\e[0mystem Update          \e[1m|\e[0m    \e[7m 2  \e[0m \e[1mR\e[0melease Compare         \e[1m|\e[0m"
    echo -e " \e[1m|\e[0m--------------------------------\e[1m|\e[0m---------------------------------\e[1m|\e[0m"
    echo -e " \e[1m|\e[0m    \e[7m 3  \e[0m \e[1mS\e[0mystem \e[1mI\e[0mnformation     \e[1m|\e[0m    \e[7m 4  \e[0m \e[1mS\e[0mhow Journal \e[1mE\e[0mrrors     \e[1m|\e[0m"
    echo -e " \e[1m|\e[0m--------------------------------\e[1m|\e[0m---------------------------------\e[1m|\e[0m"
    echo -e " \e[1m|\e[0m    \e[7m 5  \e[0m \e[1mD\e[0mmesg                  \e[1m|\e[0m    \e[7m 6  \e[0m CPU \e[1mF\e[0mrequency Info      \e[1m|\e[0m"
    echo -e " \e[1m|\e[0m--------------------------------\e[1m|\e[0m---------------------------------\e[1m|\e[0m"
    echo -e " \e[1m|\e[0m    \e[7m 7  \e[0m \e[1mPac\e[0mkage manager \e[1mUI\e[0m     \e[1m|\e[0m    \e[7m 8  \e[0m \e[1mT\e[0mranslate \e[1mS\e[0mhell         \e[1m|\e[0m"
    echo -e " \e[1m|\e[0m--------------------------------\e[1m|\e[0m---------------------------------\e[1m|\e[0m"
    echo -e " \e[1m|\e[0m    \e[7m 9  \e[0m \e[1mRa\e[0mnger (File Manager)  \e[1m|\e[0m    \e[7m 10 \e[0m \e[1mB\e[0mrowsh (Web Browser)    \e[1m|\e[0m"
    echo -e " \e[1m+------------------------------------------------------------------+\e[0m"
    echo -e "      \e[7m 00 \e[0m \e[1mU\e[0mpdate ToolBox and applications"
    echo ""
    echo -e "  Enter number and press ENTER    -    \e[7m 0  \e[0m \e[1mQ\e[0muit "

    # save entered numbers/letters in variable "choice"
    read -r choice
    # convert "choice" variable to lowercase:
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' )"
    echo


    # test, whether "choice" fits any of the following numbers, letters, or words
    case "$choice" in

        1|s|update|system-update )                                                  # the following commands will get executed if $choice is "1" or "u" or "update" until a code line containing only ";;" is encountered
            printf '\33[H\33[2J'
            cd "$HOME/.cache/toolbox"
            ./manjaro_update
            echo
            echo -e " \e[41m System updated. To return to ToolBox press ENTER \e[0m"
            # wait for input, e.g. by pressing ENTER:
            read -r
            ;;
        2|r|release|release-compare )
            printf '\33[H\33[2J'
            _releasecompare_startmenu
            echo
            echo -e " \e[41m Comparison finished. To return to ToolBox press ENTER \e[0m"
            read -r
            ;;
        3|si|system|system-information )
            printf '\33[H\33[2J'
            inxi -Fxxxza --no-host
            echo
            echo -e " \e[41m Displaying System Information. To return to ToolBox press ENTER \e[0m"
            read -r
            ;;
        4|se|show|show-system-errors )
            printf '\33[H\33[2J'
            journalctl -p 3 -xb
            echo
            echo -e " \e[41m Displaying journalctl errors. To return to ToolBox press ENTER \e[0m"
            read -r
            ;;
        5|d|dmesg )
            printf '\33[H\33[2J'
            sudo dmesg | less
            echo
            echo -e " \e[41m Displaying dmesg. To return to ToolBox press ENTER \e[0m"
            read -r
            ;;
        6|f|frequency|frequency-info )
            printf '\33[H\33[2J'
            cpupower frequency-info
            echo
            echo -e " \e[41m Displaying frequency-info. To return to ToolBox press ENTER \e[0m"
            read -r
            ;;
        7|p|pac|ui|pacui )
            cd "$HOME/.cache/toolbox"
            ./pacui
            echo
            ;;
        8|t|ts|translate|translate-shell )
            printf '\33[H\33[2J'
            gawk -f <(curl -Ls git.io/translate) -- -shell
            echo
            ;;
        9|ra|RA|ranger|Ranger )
            printf '\33[H\33[2J'
            cd "$HOME/.cache/toolbox/ranger-master"
            ./ranger.py
            echo
            echo -e " \e[41m Displaying Ranger. To return to ToolBox press ENTER \e[0m"
            read -r
            ;;

        10|B|b|browsh|Browsh )
            printf '\33[H\33[2J'
            cd "$HOME/.cache/toolbox"
            ./browsh*
            echo
            echo -e " \e[41m Displaying Browsh. To return to ToolBox press ENTER \e[0m"
            read -r
            ;;

        00|U|u )
            printf '\33[H\33[2J'
            _update_check
            echo
            echo -e " \e[41m Update finished. To return to ToolBox press ENTER \e[0m"
            read -r
            ;;

        0|q|quit|$'\e'|$'\e'$'\e' )
            ui_clean && exit                                                     # clear terminal screen first (alternatively, "reset" works as well, but then the terminal history is lost). the "exit" command quits terminal ui.
            ;;


        * )                                                                         # do this, if $choice variable contains anything else not offered above
            echo -e " \e[41m Wrong option \e[0m"
            echo -e "  Please try again...  "
            sleep 2
            ;;

    esac                                                                            # close case-loop

# now, the infinite while-loop will start again from its top by clearing the terminal screen and redrawing the UI

done                                                                                # close while-loop
